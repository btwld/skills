# Rockets SDK - Advanced Authentication Guide

This guide covers advanced authentication patterns, customization techniques, and integration strategies for the Rockets SDK (`@bitwild/rockets` and `@bitwild/rockets-auth`).

> **Important Note**: This guide contains advanced patterns and conceptual examples. Some examples may require additional services, dependencies, or custom implementations not provided by the SDK. Always verify method signatures and availability in your specific SDK version before implementation.

## Table of Contents

1. [Introduction to Advanced Authentication Patterns](#introduction-to-advanced-authentication-patterns)
2. [Custom Authentication Providers](#custom-authentication-providers)
3. [Custom Strategies and Guards](#custom-strategies-and-guards)
4. [OAuth Integration Patterns](#oauth-integration-patterns)
5. [JWT Customization Patterns](#jwt-customization-patterns)
6. [Advanced Access Control Integration](#advanced-access-control-integration)
7. [Multi-factor Authentication Patterns](#multi-factor-authentication-patterns)
8. [Session Management and Token Handling](#session-management-and-token-handling)

---

## Introduction to Advanced Authentication Patterns

The Rockets Server SDK provides a comprehensive authentication system out of the box, but many applications require custom authentication logic, additional security measures, or integration with existing systems. This guide explores advanced patterns for customizing and extending the authentication system.

### Key Authentication Components

The Rockets authentication system consists of several core components:

- **Guards**: Protect routes and validate authentication state
- **Strategies**: Handle specific authentication methods (local, JWT, OAuth)
- **Providers**: Custom services for token validation and user resolution
- **Services**: Business logic for authentication operations
- **Controllers**: HTTP endpoints for authentication flows

### Authentication Flow Overview

```typescript
// 1. User submits credentials -> AuthLocalGuard
// 2. Guard uses AuthLocalStrategy -> CustomAuthLocalValidationService
// 3. Validation service checks credentials -> User entity
// 4. Success -> IssueTokenService generates JWT tokens
// 5. Subsequent requests -> AuthJwtGuard -> RocketsJwtAuthProvider
// 6. Provider validates token -> Enriched user object with roles
```

### SDK Methods vs Custom Implementation

**What's Available in SDK:**
- `UserModelService.byId(id)` - Get user by ID
- `UserModelService.update(userData)` - Update user (data must include ID)
- `VerifyTokenService.accessToken(token)` - Verify JWT tokens
- `AuthLocalValidateUserService` - Base validation service

**What Requires Custom Implementation:**
- `UserModelService.byUsername()` - Not available, use UserLookupService
- `UserModelService.update(id, data)` - Wrong signature, use `update(data)`
- Custom user fields (failedAttempts, lastActivity) - Need custom User entity
- Security event logging - Custom implementation required

---

## Custom Authentication Providers

### Creating a Custom JWT Authentication Provider

The `RocketsJwtAuthProvider` can be extended or replaced to implement custom token validation logic. The provider pattern follows these steps:

1. Verify JWT signature and expiration via `VerifyTokenService.accessToken(token)`
2. Validate custom claims from the payload
3. Fetch the user by ID (`payload.sub`) using `UserModelService.byId()`
4. Perform additional security checks (active status, account lockout)
5. Build an enriched user object with roles, permissions, metadata
6. Return the enriched user for downstream consumers

```typescript
// Key injection pattern for a custom JWT auth provider
@Injectable()
export class CustomJwtAuthProvider {
  constructor(
    @Inject(VerifyTokenService)
    private readonly verifyTokenService: VerifyTokenService,
    @Inject(UserModelService)
    private readonly userModelService: UserModelService,
  ) {}
}
```

> Full implementation generated by custom code patterns. See `skills/rockets-custom-code/SKILL.md`.

### Custom Local Authentication with Login Attempts

Extend the default local authentication to include advanced security features like progressive delays, account lockout, and security event logging.

**Key pattern**: Extend `AuthLocalValidateUserService` and override `validateUser()`:

```typescript
@Injectable()
export class CustomAuthLocalValidationService extends AuthLocalValidateUserService {
  private readonly MAX_ATTEMPTS = 5;
  private readonly LOCKOUT_DURATION = 30 * 60 * 1000; // 30 minutes

  async validateUser(
    dto: AuthLocalValidateUserInterface,
  ): Promise<ReferenceIdInterface> {
    // 1. Look up user (use UserLookupService, not UserModelService)
    // 2. Check account lockout
    // 3. Apply progressive delay based on failedAttempts
    // 4. Call super.validateUser(dto)
    // 5. Reset failed attempts on success / increment on failure
    // 6. Log security events
  }
}
```

**Important notes:**
- `UserModelService` does not have `byUsername()` -- use `UserLookupService`
- `UserModelService.update()` takes an object with `id` included, not `(id, data)`
- Custom fields like `failedAttempts` and `lastFailedAttempt` require a custom User entity

---

## Custom Strategies and Guards

### Custom JWT Strategy with Additional Claims

Create a custom Passport JWT strategy that validates tokens through a custom provider and enriches the user object with request context:

```typescript
@Injectable()
export class CustomJwtStrategy extends PassportStrategy(Strategy, 'custom-jwt') {
  constructor(
    private configService: ConfigService,
    private customJwtAuthProvider: CustomJwtAuthProvider,
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get<string>('JWT_ACCESS_SECRET'),
      passReqToCallback: true,
    });
  }
}
```

The `validate()` method should extract the token from the request, delegate to `CustomJwtAuthProvider.validateToken()`, and attach request context (IP, User-Agent, method, URL) to the returned user object.

### Role-Based Guard with Resource Context

Use custom decorators and a guard to combine role-based access control with resource-level ownership checks:

```typescript
// Decorator definitions
export const ROLES_KEY = 'roles';
export const RESOURCE_KEY = 'resource';
export const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);
export const Resource = (resource: string) => SetMetadata(RESOURCE_KEY, resource);
```

The `RoleResourceGuard` implements `CanActivate` and:
1. Reads `ROLES_KEY` and `RESOURCE_KEY` from handler/class metadata via `Reflector`
2. Checks `user.roles` against required roles
3. For resource-specific logic, dispatches to ownership checks (e.g., `user-profile` allows self-access, `sensitive-data` requires admin)

### Usage in Controllers

```typescript
@Controller('users')
@UseGuards(AuthJwtGuard, RoleResourceGuard)
export class UserProfileController {
  @Get(':id/profile')
  @Roles('user', 'admin')
  @Resource('user-profile')
  getUserProfile(@Param('id') id: string) {
    return { message: `Profile for user ${id}` };
  }

  @Get('admin/sensitive')
  @Roles('admin')
  @Resource('sensitive-data')
  getSensitiveData() {
    return { message: 'Sensitive administrative data' };
  }
}
```

---

## OAuth Integration Patterns

### Custom OAuth Strategy

Extend OAuth integration to support custom providers using `passport-oauth2`:

```typescript
@Injectable()
export class CustomOAuthStrategy extends PassportStrategy(Strategy, 'custom-oauth') {
  constructor(private configService: ConfigService) {
    super({
      authorizationURL: configService.get('CUSTOM_OAUTH_AUTH_URL'),
      tokenURL: configService.get('CUSTOM_OAUTH_TOKEN_URL'),
      clientID: configService.get('CUSTOM_OAUTH_CLIENT_ID'),
      clientSecret: configService.get('CUSTOM_OAUTH_CLIENT_SECRET'),
      callbackURL: configService.get('CUSTOM_OAUTH_CALLBACK_URL'),
      scope: ['openid', 'profile', 'email'],
    });
  }
}
```

The `validate()` method receives `accessToken`, `refreshToken`, and `profile`, and should map them to a normalized user profile object with `provider`, `providerId`, `email`, `firstName`, `lastName`, `avatar`, and the tokens.

### OAuth User Creation Service

Handle OAuth user creation and linking with the following flow:

1. Check if a federated account exists for the provider/subject pair (`FederatedModelService.findOne()`)
2. If found, return the linked user
3. Otherwise, check if a user exists by email (`UserModelService.byEmail()`)
4. If no user, create one with a random password (OAuth users don't use password auth)
5. Create the federated account link (`FederatedModelService.create()`)
6. Return the user

> Full implementation generated by custom code patterns. See `skills/rockets-custom-code/SKILL.md`.

---

## JWT Customization Patterns

### Custom JWT Payload

Extend JWT tokens with custom claims by extending `IssueTokenService`. The custom payload can include:

- `sub` (user ID), `email`, `roles`, `permissions`
- User metadata fields (department, organizationId)
- Custom claims: feature flags, subscription tier
- Standard claims: `iat`, `exp`

**Pattern**: Override `createAccessToken(userId)`, fetch user data via `UserModelService.byId()`, build the enriched payload, and sign it.

### Token Refresh Strategy

Implement custom token refresh logic by extending `RefreshTokenService`. The refresh flow should:

1. Verify the refresh token
2. Check if the token is blacklisted
3. Verify user status (active account)
4. Generate new access and refresh tokens
5. Blacklist the old refresh token (rotation)
6. Update last login timestamp

> Full implementation generated by custom code patterns. See `skills/rockets-custom-code/SKILL.md`.

---

## Advanced Access Control Integration

### Custom Access Control Service

Implement `AccessControlServiceInterface` for advanced role resolution with contextual roles:

```typescript
@Injectable()
export class AdvancedAccessControlService implements AccessControlServiceInterface {
  async getUser<T>(context: ExecutionContext): Promise<T> {
    const request = context.switchToHttp().getRequest();
    return request.user as T;
  }

  async getUserRoles(context: ExecutionContext): Promise<string | string[]> {
    const user = await this.getUser(context);
    const roles = user.userRoles?.map(ur => ur.role.name) || [];
    const contextRoles = await this.getContextualRoles(user, request);
    return [...roles, ...contextRoles];
  }
}
```

**Contextual role patterns:**
- **Organization-based roles**: Look up the user's role within their organization
- **Resource ownership roles**: Add `'owner'` role when user owns the requested resource (check by `request.params.id` against resource-specific ownership logic)
- **Time-based roles**: Add `'business_hours'` or `'after_hours'` based on current time

### Resource-Specific Access Query Service

Create custom access query services implementing `CanAccessQueryService` for complex ownership filtering:

```typescript
@Injectable()
export class PetAccessQueryService implements CanAccessQueryService {
  async canAccess(query, queryRunner, user, permission) {
    if (permission.endsWith('Own')) {
      return query.andWhere('entity.ownerId = :userId', { userId: user.id });
    }
    if (permission.endsWith('Any') && this.hasAnyAccess(user)) {
      return query; // No additional filtering
    }
    return this.applyOwnershipFilter(query, user); // Fallback
  }
}
```

**Decision tree for access query filtering:**
- `*Own` permissions: Always apply ownership filter (`entity.ownerId = user.id`)
- `*Any` permissions with admin/manager role: No additional filtering
- `*Any` permissions without elevated role: Fall back to ownership filter

---

## Multi-factor Authentication Patterns

### TOTP (Time-based One-Time Password) Implementation

Implement TOTP MFA using the `speakeasy` and `qrcode` libraries. The service should provide:

- **`generateTotpSecret(userId, email)`**: Generate a TOTP secret, QR code URL, and backup codes. Store encrypted in database.
- **`verifyTotp(userId, token)`**: Verify the TOTP token with a 1-step time window. Fall back to backup code validation if TOTP fails.

### MFA Guard

Create a guard using `Reflector` to read a `requireMfa` metadata flag:

```typescript
@Injectable()
export class MfaGuard implements CanActivate {
  async canActivate(context: ExecutionContext): Promise<boolean> {
    const requireMfa = this.reflector.get<boolean>('requireMfa', context.getHandler());
    if (!requireMfa) return true;

    const user = context.switchToHttp().getRequest().user;
    // 1. Check user is authenticated
    // 2. Check MFA is enabled for user
    // 3. Check current session/token has mfaVerified === true
    return true;
  }
}
```

---

## Session Management and Token Handling

### Redis-based Session Management

Use Redis for session storage with the following capabilities:

- **Create session**: Store session data (userId, IP, user-agent, mfaVerified) with a 7-day TTL. Track active sessions per user via a Redis set.
- **Get/Update session**: Retrieve session by ID, update with new data and reset TTL on activity.
- **Destroy session**: Remove from Redis and from the user's active session set.
- **List user sessions**: Retrieve all active sessions for a user, cleaning up stale references.
- **Destroy all user sessions**: Bulk invalidation for password changes or security events.

> Full implementation generated by custom code patterns. See `skills/rockets-custom-code/SKILL.md`.

### Token Blacklist Service

Use Redis to blacklist revoked tokens with automatic TTL-based cleanup:

**Key patterns:**
- Store a SHA-256 hash of the token (not the token itself) with a TTL matching the token's remaining lifetime
- Use a per-user "token version" counter (`token_version:{userId}`) to bulk-invalidate all tokens for a user
- Include the version in JWT payloads; reject tokens where `payload.version < currentVersion`

### Enhanced Token Validation

Combine blacklist checking, token versioning, and session validation into a unified validation pipeline:

1. Check if token is blacklisted
2. Compare `payload.version` against user's current token version
3. If `payload.sessionId` exists, validate the session and update its activity timestamp
4. Perform additional custom validations (IP restrictions, geo-fencing, device fingerprinting)

---

## Configuration and Module Setup

### Authentication Module Configuration

When setting up the complete authentication module, register custom services in both the `RocketsModule.forRootAsync()` configuration and the module's `providers` array:

```typescript
RocketsModule.forRootAsync({
  useFactory: (configService, customValidationService) => ({
    authLocal: {
      validateUserService: customValidationService,
    },
    jwt: {
      settings: {
        access: { secret: configService.get('JWT_ACCESS_SECRET'), expiresIn: '1h' },
        refresh: { secret: configService.get('JWT_REFRESH_SECRET'), expiresIn: '7d' },
      },
    },
  }),
})
```

**Module providers to register:**
- `CustomAuthLocalValidationService`, `CustomJwtAuthProvider`, `CustomJwtStrategy`
- `TotpMfaService`, `SessionManagementService`, `TokenBlacklistService`
- `AdvancedAccessControlService`, `RoleResourceGuard`, `MfaGuard`

This authentication guide provides advanced patterns for customizing and extending the Rockets Server SDK authentication system. Each pattern addresses specific use cases while maintaining security best practices and integrating seamlessly with the existing SDK architecture.
