# DTO PATTERNS GUIDE

> **For AI Tools**: This guide contains DTO creation patterns and validation strategies for Rockets SDK. Use this when building API contracts and validation schemas.

## Quick Reference

| Task | Section | Time |
|------|---------|------|
| Create main entity DTO | [Base DTO Pattern](#base-dto-pattern) | 10 min |
| Create/Update DTOs | [CRUD DTO Patterns](#crud-dto-patterns) | 15 min |
| Add validation decorators | [Validation Patterns](#validation-patterns) | 10 min |
| Paginated responses | [Pagination DTOs](#pagination-dtos) | 5 min |
| Handle relationships | [Relationship DTOs](#relationship-dtos) | 15 min |

---

## First-round DTO rules (catch before review)

Apply these on every new or response DTO so `/rockets-review` doesn't flag them:

1. **@Exclude() at class level on ALL DTOs** — Add `@Exclude()` (from `class-transformer`) at the top of **every** DTO class — base DTOs, Create DTOs, CreateMany DTOs, Update DTOs, ModelUpdate DTOs, and Paginated DTOs. Derived DTOs from `PickType`/`IntersectionType`/`PartialType` do **not** reliably inherit `@Exclude()` from the parent. Always add it explicitly.
2. **Nested objects / arrays of objects** — For any property that is an object or array of objects (e.g. `items: UserTaskReportItemDto[]`, `bulk: CreateDto[]`):
   - Use `@IsArray()` for array properties.
   - Use `@ValidateNested()` (and `@ValidateNested({ each: true })` for arrays).
   - Use `@Type(() => ChildDto)` so class-transformer and validation work on the nested type.
   - Without `@ValidateNested()`, nested items are NOT validated — invalid data passes through silently.
3. **Ownership fields NEVER in create DTOs** — Fields that represent resource ownership (e.g. `userId`, `ownerId`, `createdById`) must NOT be accepted from the request body. Remove them from `CreateDto` pick fields. Instead, inject `@AuthUser()` in the controller and set `dto.userId = user.id` before passing to the service. This prevents users from creating resources assigned to other users.

---

## Base DTO Pattern

### SDK DTO Extension Pattern

When working with Rockets SDK, extend from SDK DTOs when they exist. For **user-metadata DTOs**, the SDK does NOT export create/update DTOs — you must create them from scratch.

**Available SDK base DTOs** (from `@bitwild/rockets-auth`):
- `RocketsAuthUserDto` — for User base DTO
- `RocketsAuthUserCreateDto` — for User create DTO
- `RocketsAuthUserUpdateDto` — for User update DTO
- `RocketsAuthRoleDto` — for Role base DTO
- `RocketsAuthRoleCreateDto` — for Role create DTO
- `RocketsAuthRoleUpdateDto` — for Role update DTO
- `RocketsAuthUserMetadataDto` — for UserMetadata base DTO
- `RocketsAuthUserMetadataCreateDto` — **NOT exported, create custom**
- `RocketsAuthUserMetadataUpdateDto` — **NOT exported, create custom**

Custom UserMetadata create/update DTOs follow the same `@Exclude()` + `@Expose()` + validator pattern as any other DTO. Include `userId` (create) or `id` (update) as required fields.

For the base metadata DTO with custom fields, extend from `RocketsAuthUserMetadataDto` and add `@Expose()` + validation decorators for each custom field (e.g. `age`, `firstName`, `avatarUrl`).

### Main Entity DTO Structure

All entity DTOs follow this standardized pattern:

```typescript
@Exclude()
export class ArtistDto extends CommonEntityDto implements ArtistInterface {
  @Expose()
  @ApiProperty({ description: 'Artist name', example: 'The Beatles', maxLength: 255 })
  @IsString()
  @IsNotEmpty()
  @MinLength(1, { message: 'Artist name must be at least 1 character' })
  @MaxLength(255, { message: 'Artist name cannot exceed 255 characters' })
  name!: string;

  // ... additional @Expose() fields with validation
}
```

> Generated by rockets-crud-generator skill. See `skills/rockets-crud-generator/SKILL.md`.

**Key Patterns:**

- **Extend CommonEntityDto**: Provides `id`, `dateCreated`, `dateUpdated`, `dateDeleted`
- **Use @Exclude()**: Start with exclusion for security, explicitly expose needed fields
- **Implement Interface**: Ensure type safety with business interface
- **Complete ApiProperty**: Full Swagger documentation with examples and constraints
- **Validation Decorators**: Both class-validator rules and custom error messages
- **Optional Fields**: Use `@IsOptional()` with proper typing

---

## CRUD DTO Patterns

### Create DTO Pattern

Use `PickType` to select required fields from the base DTO, then add optional fields with defaults:

```typescript
@Exclude()
export class ArtistCreateDto
  extends PickType(ArtistDto, ['name'] as const)
  implements ArtistCreatableInterface {

  @Expose()
  @IsOptional()
  @IsEnum(ArtistStatus)
  status?: ArtistStatus;
}
```

#### SDK DTO Extension Pattern (UserMetadata)

```typescript
export class UserMetadataCreateDto extends PickType(UserMetadataDto, [
  'userId', 'age', 'firstName', 'lastName', 'avatarUrl', 'skills'
] as const) implements UserMetadataCreatableInterface {}
```

### Create Many DTO Pattern

```typescript
@Exclude()
export class ArtistCreateManyDto {
  @ApiProperty({ type: [ArtistCreateDto], description: 'Array of artists to create' })
  @Type(() => ArtistCreateDto)
  @IsArray()
  @ValidateNested({ each: true })
  @ArrayMinSize(1, { message: 'At least one item must be provided' })
  @ArrayMaxSize(100, { message: 'Cannot create more than 100 items at once' })
  bulk!: ArtistCreateDto[];
}
```

### Update DTO Pattern

Combine required `id` with optional updatable fields:

```typescript
export class ArtistUpdateDto extends IntersectionType(
  PickType(ArtistDto, ['id'] as const),
  PartialType(PickType(ArtistDto, ['name', 'status', 'biography', 'country'] as const)),
) implements ArtistUpdatableInterface {}
```

#### SDK DTO Extension Pattern (UserMetadata)

```typescript
export class UserMetadataUpdateDto extends IntersectionType(
  PickType(UserMetadataDto, ['id'] as const),
  PartialType(PickType(UserMetadataDto, [
    'age', 'firstName', 'lastName', 'avatarUrl', 'skills'
  ] as const))
) implements UserMetadataUpdatableInterface {}
```

### Model Update DTO Pattern

```typescript
export class ArtistModelUpdateDto extends PartialType(
  PickType(ArtistDto, ['name', 'status', 'biography', 'country'] as const)
) implements ArtistModelUpdatableInterface {
  id!: string; // Required — satisfies ReferenceIdInterface<string>
}
```

---

## Pagination DTOs

### Paginated Response DTO

Key rule: use `declare data:` (NOT `!:`) because the base class already defines the property.

```typescript
export class ArtistPaginatedDto extends CrudResponsePaginatedDto<ArtistDto> {
  @ApiProperty({ type: [ArtistDto], description: 'Array of artists' })
  declare data: ArtistDto[]; // MUST use 'declare' — '!' causes TS2612
}
```

> Full paginated DTO (with meta) generated by rockets-crud-generator skill. See `skills/rockets-crud-generator/SKILL.md`.

### Search/Filter DTO

Search DTOs use `@IsOptional()` + `@Type(() => Number)` for query params. Include `page` and `limit` with defaults:

```typescript
@IsOptional()
@Type(() => Number)
@IsInt()
@Min(1)
page?: number = 1;

@IsOptional()
@Type(() => Number)
@IsInt()
@Min(1)
@Max(100)
limit?: number = 10;
```

> Full search DTOs generated by rockets-crud-generator skill. See `skills/rockets-crud-generator/SKILL.md`.

---

## Relationship DTOs

### Entity with Relationships

```typescript
export class ArtistWithAlbumsDto extends ArtistDto {
  @Expose()
  @ApiProperty({ type: [AlbumDto], description: 'Albums by this artist', required: false })
  @Type(() => AlbumDto)
  @IsOptional()
  @IsArray()
  @ValidateNested({ each: true })
  albums?: AlbumDto[];
}
```

### Nested Create DTO

```typescript
export class AlbumCreateWithArtistDto extends AlbumCreateDto {
  @ApiProperty({ description: 'Artist ID', format: 'uuid' })
  @IsNotEmpty()
  @IsUUID(4, { message: 'Artist ID must be a valid UUID' })
  artistId!: string;

  @ApiProperty({ type: ArtistCreateDto, required: false })
  @IsOptional()
  @ValidateNested()
  @Type(() => ArtistCreateDto)
  artist?: ArtistCreateDto;
}
```

---

## Validation Patterns

### String Validation

```typescript
// Basic string with length constraints
@IsString()
@IsNotEmpty()
@MinLength(1, { message: 'Name is required' })
@MaxLength(255, { message: 'Name cannot exceed 255 characters' })
name!: string;

// Optional string with validation
@IsOptional()
@IsString()
@MaxLength(2000, { message: 'Description cannot exceed 2000 characters' })
description?: string;

// Email validation
@IsEmail({}, { message: 'Please provide a valid email address' })
@MaxLength(320, { message: 'Email cannot exceed 320 characters' })
email!: string;

// URL validation
@IsOptional()
@IsUrl({}, { message: 'Please provide a valid URL' })
website?: string;
```

### Numeric Validation

```typescript
// Integer with range
@Type(() => Number)
@IsInt({ message: 'Age must be an integer' })
@Min(0, { message: 'Age cannot be negative' })
@Max(150, { message: 'Age cannot exceed 150' })
age!: number;

// Decimal with precision
@Type(() => Number)
@IsNumber({ maxDecimalPlaces: 2 }, { message: 'Price must have at most 2 decimal places' })
@Min(0.01, { message: 'Price must be at least 0.01' })
price!: number;

// Positive integer
@Type(() => Number)
@IsPositive({ message: 'Quantity must be positive' })
@IsInt({ message: 'Quantity must be an integer' })
quantity!: number;
```

### Date Validation

```typescript
// Date validation
@Type(() => Date)
@IsDate({ message: 'Please provide a valid date' })
releaseDate!: Date;

// Date with transform validation
@Type(() => Date)
@IsDate()
@IsOptional()
@Transform(({ value }) => {
  const date = new Date(value);
  if (date > new Date()) throw new Error('Date cannot be in the future');
  return date;
})
birthDate?: Date;
```

### Array Validation

```typescript
// Array of strings
@IsArray()
@IsString({ each: true })
@ArrayMinSize(1, { message: 'At least one tag is required' })
@ArrayMaxSize(10, { message: 'Cannot have more than 10 tags' })
tags!: string[];

// Array of objects
@IsArray()
@ValidateNested({ each: true })
@Type(() => SongDto)
@ArrayMinSize(1, { message: 'Must have at least one item' })
songs!: SongDto[];

// Optional UUID array
@IsOptional()
@IsArray()
@IsUUID(4, { each: true, message: 'Each ID must be a valid UUID' })
categoryIds?: string[];
```

### Custom Validation

```typescript
function IsNotProfane(validationOptions?: ValidationOptions) {
  return function (object: Object, propertyName: string) {
    registerDecorator({
      name: 'isNotProfane',
      target: object.constructor,
      propertyName,
      options: validationOptions,
      validator: {
        validate(value: any) {
          const blocked = ['badword1', 'badword2'];
          return !blocked.some(w => value?.toLowerCase().includes(w));
        },
        defaultMessage() {
          return 'Text contains inappropriate content';
        },
      },
    });
  };
}
```

---

## Advanced Patterns

### Conditional Validation

```typescript
@IsEnum(['text', 'image', 'video'])
type!: string;

@ValidateIf(o => o.type === 'text')
@IsNotEmpty({ message: 'Text content is required for text type' })
@IsString()
textContent?: string;

@ValidateIf(o => o.type === 'image')
@IsNotEmpty({ message: 'Image URL is required for image type' })
@IsUrl()
imageUrl?: string;
```

### Transform and Sanitize

```typescript
// Trim and title-case
@Transform(({ value }) =>
  typeof value === 'string'
    ? value.trim().replace(/\w\S*/g, t => t.charAt(0).toUpperCase() + t.substr(1).toLowerCase())
    : value
)
@IsString()
@IsNotEmpty()
name!: string;

// Deduplicate and normalize tags
@Transform(({ value }) =>
  Array.isArray(value)
    ? [...new Set(value.map(t => t.trim().toLowerCase()).filter(Boolean))]
    : value
)
@IsArray()
@IsString({ each: true })
tags!: string[];
```

---

## Best Practices

### 1. Use Composition Over Inheritance
```typescript
// GOOD - Use PickType and IntersectionType
export class ArtistUpdateDto extends IntersectionType(
  PickType(ArtistDto, ['id'] as const),
  PartialType(PickType(ArtistDto, ['name', 'status'] as const)),
) {}

// AVOID - Copying fields manually
export class ArtistUpdateDto {
  id: string;
  name?: string;
}
```

### 2. Provide Meaningful Error Messages
```typescript
// GOOD - Specific error messages
@MinLength(2, { message: 'Artist name must be at least 2 characters long' })

// AVOID - No message
@MinLength(2)
```

### 3. Use Transform for Data Cleaning
```typescript
// GOOD - Clean and normalize data
@Transform(({ value }) => value?.trim().toLowerCase())
@IsEmail()
email!: string;
```

### 4. Implement Interface Compliance
```typescript
// GOOD
export class ArtistCreateDto implements ArtistCreatableInterface { ... }

// AVOID - No type safety
export class ArtistCreateDto { ... }
```

### 5. Use Proper API Documentation
```typescript
// GOOD - Complete documentation
@ApiProperty({
  description: 'Artist unique identifier',
  example: '123e4567-e89b-12d3-a456-426614174000',
  format: 'uuid',
  readOnly: true,
})
```

---

## Success Checklist

- All DTOs extend appropriate base classes (CommonEntityDto)
- Proper composition using PickType, PartialType, IntersectionType
- Complete validation with meaningful error messages
- Full Swagger documentation with examples
- Interface compliance for type safety
- Data transformation and sanitization
- Consistent naming and structure patterns
- Relationship handling for complex data

---

## Related Guides

- [TESTING_GUIDE.md](./TESTING_GUIDE.md) - Test DTO validation
- [CRUD_PATTERNS_GUIDE.md](./CRUD_PATTERNS_GUIDE.md) - Use DTOs in CRUD
- [CONFIGURATION_GUIDE.md](./CONFIGURATION_GUIDE.md) - SDK configuration
- `rockets-crud-generator` skill - Generate DTOs automatically
- [ROCKETS_AI_INDEX.md](./ROCKETS_AI_INDEX.md) - Navigation hub
