# Advanced Entity Patterns Guide

This guide focuses on advanced entity patterns, complex relationships, and performance optimization techniques when working with the Rockets SDK. It covers enterprise-level patterns for extending SDK entities and implementing complex business domains.

## Table of Contents

1. [Introduction to Advanced Entity Patterns](#introduction-to-advanced-entity-patterns)
2. [Custom User Entity Extension Patterns](#custom-user-entity-extension-patterns)
3. [Role, UserRole, UserOtp, and Federated Entity Examples](#role-userrole-userotp-and-federated-entity-examples)
4. [Complex Relationship Management Patterns](#complex-relationship-management-patterns)
5. [Database View Patterns for Complex Queries](#database-view-patterns-for-complex-queries)
6. [Entity Inheritance Patterns](#entity-inheritance-patterns)
7. [Advanced TypeORM Patterns for SDK Integration](#advanced-typeorm-patterns-for-sdk-integration)
8. [Performance Optimization Techniques for Entities](#performance-optimization-techniques-for-entities)

## Introduction to Advanced Entity Patterns

The Rockets SDK provides a robust foundation for building enterprise applications with complex entity relationships. This guide covers advanced patterns that go beyond basic CRUD operations to handle sophisticated business domains.

### Core Principles

- **Separation of Concerns**: Business logic in services, data access through adapters
- **Type Safety**: Comprehensive interfaces and proper TypeScript patterns
- **Extensibility**: Proper inheritance and composition patterns
- **Performance**: Optimized queries and caching strategies
- **Maintainability**: Consistent patterns and clear abstractions

### When to Use Advanced Patterns

Use these patterns when you need:
- Complex multi-entity relationships
- Custom business validation logic
- Performance-optimized read operations
- Domain-specific entity behaviors
- Integration with external systems

## Custom User Entity Extension Patterns

### Basic User Entity Extension

The foundation of most advanced patterns starts with properly extending the base User entity. Key techniques:

- Extend `UserSqliteEntity` (or `UserPostgresEntity`) and implement your custom interface
- Add composite indexes for common query patterns (e.g., `['email', 'active']`)
- Group columns logically: personal info, metadata fields, relationships

```typescript
@Entity('user')
@Index(['email', 'active'])
@Index(['username', 'active'])
export class UserEntity extends UserSqliteEntity implements UserEntityInterface {
  @Column({ type: 'varchar', length: 50, nullable: true })
  @Index()
  firstName?: string;

  @OneToMany(() => UserOtpEntity, (userOtp) => userOtp.assignee)
  userOtps?: UserOtpEntity[];
}
```

> Generated by rockets-crud-generator skill. See skills/rockets-crud-generator/SKILL.md.

### Advanced User Interface Pattern

Extend `RocketsServerUserEntityInterface` to add custom fields and business methods to the interface. Keep the interface in sync with the entity columns and relationships.

> Generated by rockets-crud-generator skill. See skills/rockets-crud-generator/SKILL.md.

### User Metadata Entity Pattern

For complex user metadata that requires its own CRUD operations, create a separate entity with a `@OneToOne` relationship to the user. Use JSON columns for nested structured data (e.g., `personalInfo`, `socialLinks`, `settings`):

```typescript
@Entity('user_metadata')
@Index(['userId'])
export class UserMetadataEntity extends AuditSqliteEntity {
  @Column({ type: 'varchar', nullable: false, unique: true })
  userId!: string;

  @Column({ type: 'json', nullable: true })
  settings?: { notifications?: { email?: boolean }; privacy?: { profilePublic?: boolean } };

  @OneToOne(() => UserEntity)
  @JoinColumn({ name: 'userId' })
  user?: UserEntity;
}
```

## Role, UserRole, UserOtp, and Federated Entity Examples

### Advanced Role Entity with Permissions

Extend `RolePostgresEntity` and add:
- A `priority` column with `@Index()` for role hierarchy ordering
- A `restrictions` JSON column for max users, allowed domains, and time restrictions
- A `@ManyToMany` relationship with a `PermissionEntity` through a `role_permission` join table

```typescript
@ManyToMany(() => PermissionEntity)
@JoinTable({
  name: 'role_permission',
  joinColumn: { name: 'roleId', referencedColumnName: 'id' },
  inverseJoinColumn: { name: 'permissionId', referencedColumnName: 'id' },
})
permissions?: PermissionEntity[];
```

> Generated by rockets-crud-generator skill. See skills/rockets-crud-generator/SKILL.md.

### Enhanced UserRole Entity with Temporal Data

Extend `RoleAssignmentSqliteEntity` and add temporal fields (`validFrom`, `validUntil`) with a composite index for time-based queries. Include context fields like `assignedBy`, `assignmentReason`, and a JSON `context` column for department/project/location scoping.

Key relationship pattern -- use `onDelete: 'CASCADE'` on both sides:

```typescript
@ManyToOne(() => RoleEntity, (role) => role.userRoles, {
  nullable: false,
  onDelete: 'CASCADE',
})
role!: RoleEntity;
```

> Generated by rockets-crud-generator skill. See skills/rockets-crud-generator/SKILL.md.

### Advanced UserOtp Entity with Categories

Extend `OtpSqliteEntity` and add a category enum (`verification`, `password_reset`, `two_factor`, etc.) with rate-limiting fields (`attemptCount`, `maxAttempts`, `lastAttemptAt`) and security tracking (`ipAddress`, `userAgent`).

Index strategy for OTP entities:

```typescript
@Index(['category', 'expiresAt'])       // For cleanup and validation queries
@Index(['assigneeId', 'category', 'active']) // For user-specific OTP queries
```

> Generated by rockets-crud-generator skill. See skills/rockets-crud-generator/SKILL.md.

### Enhanced Federated Entity for OAuth Management

Extend `FederatedSqliteEntity` and add a provider enum (`google`, `facebook`, `github`, etc.), token storage (`accessToken`, `refreshToken`, `tokenExpiresAt`), and a `profile` JSON column.

Key: use a unique composite index to prevent duplicate federated accounts:

```typescript
@Index(['provider', 'externalId'], { unique: true })
```

> Generated by rockets-crud-generator skill. See skills/rockets-crud-generator/SKILL.md.

## Complex Relationship Management Patterns

### Many-to-Many with Rich Junction Tables

When a many-to-many relationship needs extra data (roles, status, permissions, timestamps), use a dedicated junction entity rather than `@ManyToMany` + `@JoinTable`. Extend `AuditSqliteEntity` and add:

- FK columns (`projectId`, `userId`) with a unique composite index
- Role and status enums with an index on `['role', 'status']`
- Temporal fields (`joinedAt`, `invitedAt`, `invitedBy`)
- A JSON `permissions` column for fine-grained per-membership controls

```typescript
@Entity('project_member')
@Index(['projectId', 'userId'], { unique: true })
@Index(['role', 'status'])
export class ProjectMemberEntity extends AuditSqliteEntity {
  @ManyToOne(() => ProjectEntity, (project) => project.members, { onDelete: 'CASCADE' })
  project!: ProjectEntity;

  @ManyToOne(() => UserEntity, { onDelete: 'CASCADE' })
  user!: UserEntity;
}
```

> Generated by rockets-crud-generator skill. See skills/rockets-crud-generator/SKILL.md.

### Polymorphic Relationships Pattern

Use a `commentableType` + `commentableId` pair to point to different entity types from a single table. This avoids multiple nullable FK columns and scales to any number of commentable types.

```typescript
@Entity('comment')
@Index(['commentableType', 'commentableId'])
export class CommentEntity extends AuditSqliteEntity {
  @Column({ type: 'varchar', length: 50 })
  commentableType!: CommentableType; // 'post' | 'project' | 'task' | 'document'

  @Column({ type: 'varchar', length: 255 })
  commentableId!: string;

  @Column({ type: 'varchar', length: 255, nullable: true })
  parentId?: string; // For threaded/nested comments
}
```

> Generated by rockets-crud-generator skill. See skills/rockets-crud-generator/SKILL.md.

### Self-Referencing Hierarchical Entities

For tree structures (categories, org charts), use a materialized path pattern with `parentId`, `path` (e.g., `/1/2/3/`), and `level` columns. This enables efficient ancestor/descendant queries without recursive CTEs.

Key indexes and relationship pattern:

```typescript
@Index(['parentId', 'active'])
@Index(['path'])
@Index(['level', 'sortOrder'])
export class CategoryEntity extends AuditSqliteEntity {
  @Column({ type: 'text', nullable: true })
  path?: string; // Materialized path: /1/2/3/

  @Column({ type: 'integer', default: 0 })
  level!: number;

  @ManyToOne(() => CategoryEntity, (cat) => cat.children, { nullable: true, onDelete: 'CASCADE' })
  parent?: CategoryEntity;

  @OneToMany(() => CategoryEntity, (cat) => cat.parent)
  children?: CategoryEntity[];
}
```

> Generated by rockets-crud-generator skill. See skills/rockets-crud-generator/SKILL.md.

## Database View Patterns for Complex Queries

### When to Use Database Views

Use `@ViewEntity` when you need:
- Pre-aggregated data for dashboards (counts, sums, averages)
- Denormalized read models that join multiple tables
- Computed status fields derived from temporal data
- Read-only endpoints that must be fast without complex joins at query time

### User Summary View with Aggregated Data

Define a `@ViewEntity` with a SQL `expression` that joins users, roles, comments, projects, OTPs, and federated accounts. Map aggregated columns to `@ViewColumn()` properties.

Key aggregation techniques in the view SQL:
- `array_agg(DISTINCT r.name)` for role name arrays
- `COUNT(DISTINCT ...) FILTER (WHERE ...)` for conditional counts
- `CASE WHEN ... THEN ... END` for computed status fields (e.g., `activity_status`)

> Generated by rockets-crud-generator skill. See skills/rockets-crud-generator/SKILL.md.

### View Adapter Pattern

Wrap a `@ViewEntity` in a read-only adapter that extends `TypeOrmCrudAdapter`. Add custom query methods for the view's specific use cases (e.g., `findActiveUsers()`, `getUserActivitySummary()`).

```typescript
@Injectable()
export class UserSummaryViewAdapter extends TypeOrmCrudAdapter<UserSummaryViewEntity> {
  constructor(
    @InjectRepository(UserSummaryViewEntity)
    private readonly repository: Repository<UserSummaryViewEntity>,
  ) {
    super(repository);
  }
}
```

## Entity Inheritance Patterns

### Abstract Base Entity Pattern

Create an abstract base class extending `AuditSqliteEntity` for shared audit fields (`createdBy`, `updatedBy`, IP addresses, audit metadata). All domain entities extend this base instead of `AuditSqliteEntity` directly.

```typescript
export abstract class AuditableEntityBase extends AuditSqliteEntity {
  @Column({ type: 'varchar', length: 255, nullable: true })
  @Index()
  createdBy?: string;

  @Column({ type: 'varchar', length: 255, nullable: true })
  @Index()
  updatedBy?: string;

  @Column({ type: 'json', nullable: true })
  auditMetadata?: { userAgent?: string; sessionId?: string; correlationId?: string };
}
```

### Taggable Mixin Pattern

Use a TypeScript mixin function to compose tagging behavior into any entity. The mixin adds `quickTags` (simple-array) and a `@ManyToMany` relationship to a `TagEntity`.

```typescript
export function TaggableMixin<T extends new (...args: any[]) => {}>(Base: T) {
  class TaggableClass extends Base {
    @Column({ type: 'simple-array', nullable: true })
    quickTags?: string[];

    @ManyToMany(() => TagEntity)
    @JoinTable({ name: 'entity_tags' })
    tags?: TagEntity[];
  }
  return TaggableClass;
}
```

### Versioned Entity Pattern

A mixin that adds version tracking: `versionNumber`, `isCurrentVersion`, `originalEntityId`, and a `createNewVersion()` method that clones the entity with an incremented version.

```typescript
export function VersionedMixin<T extends new (...args: any[]) => {}>(Base: T) {
  class VersionedClass extends Base {
    @Column({ type: 'integer', default: 1 })
    versionNumber!: number;

    @Column({ type: 'boolean', default: true })
    isCurrentVersion!: boolean;

    @Column({ type: 'varchar', length: 255, nullable: true })
    originalEntityId?: string;
  }
  return VersionedClass;
}
```

### Using Mixins in Entity Classes

Compose multiple mixins by nesting them in the `extends` clause:

```typescript
@Entity('document')
export class DocumentEntity extends VersionedMixin(TaggableMixin(AuditableEntityBase)) {
  @Column({ type: 'varchar', length: 255 })
  title!: string;

  @Column({ type: 'text' })
  content!: string;
}
```

This gives `DocumentEntity` all columns and methods from `AuditableEntityBase`, `TaggableMixin`, and `VersionedMixin`.

## Advanced TypeORM Patterns for SDK Integration

### Custom Repository Pattern

Create a dedicated `@Injectable()` repository class that wraps the TypeORM `Repository` and `DataSource` for complex queries. Key techniques:

- **Dynamic query building**: Build `SelectQueryBuilder` chains conditionally based on search criteria
- **Paginated search**: Use `getManyAndCount()` with `skip()` and `take()` for offset pagination
- **Eager join loading**: Use `leftJoinAndSelect()` to load complete profiles in a single query
- **Role-based activity queries**: Join through `userRoles` -> `role` and aggregate with raw SQL

```typescript
@Injectable()
export class UserRepository {
  constructor(
    @InjectRepository(UserEntity)
    private readonly repository: Repository<UserEntity>,
    private readonly dataSource: DataSource,
  ) {}

  async findWithCompleteProfile(userId: string): Promise<UserEntity | null> {
    return this.repository
      .createQueryBuilder('user')
      .leftJoinAndSelect('user.userRoles', 'userRole')
      .leftJoinAndSelect('userRole.role', 'role')
      .leftJoinAndSelect('user.federatedAccounts', 'federated')
      .where('user.id = :userId', { userId })
      .getOne();
  }
}
```

> Generated by rockets-crud-generator skill. See skills/rockets-crud-generator/SKILL.md.

### Advanced Model Service Pattern

Extend `ModelService` from `@concepta/nestjs-typeorm-ext` to add business logic on top of basic CRUD. Combine the SDK model service with a custom repository for advanced queries.

Decision tree for choosing the right service layer:
- **Simple CRUD** -> use the generated `TypeOrmCrudAdapter` directly
- **Business logic on create/update** -> extend `ModelService` with custom methods
- **Complex search/aggregation** -> inject a custom `Repository` class alongside the model service

> Generated by rockets-crud-generator skill. See skills/rockets-crud-generator/SKILL.md.

## Performance Optimization Techniques for Entities

### Database Indexing Strategies

Rules for indexing in Rockets entities:

1. **Composite indexes** for common query patterns: `@Index(['email', 'active'])`, `@Index(['isVerified', 'active', 'dateCreated'])`
2. **Individual indexes** on columns used in `WHERE`, `ORDER BY`, or `JOIN` conditions
3. **Unique constraints** via `@Unique(['email'])` for business-rule enforcement
4. **Denormalized fields** (e.g., `fullName`) with their own indexes for search performance
5. **Computed status columns** (e.g., `activityStatus`) to avoid runtime CASE expressions in queries

```typescript
@Entity('user')
@Index(['email', 'active'])
@Index(['isVerified', 'active', 'dateCreated'])
@Unique(['email'])
export class OptimizedUserEntity extends UserSqliteEntity {
  @Column({ type: 'varchar', length: 101, nullable: true })
  @Index()
  fullName?: string; // Denormalized for search

  @Column({ type: 'varchar', length: 20, default: 'active' })
  @Index()
  activityStatus?: 'active' | 'inactive' | 'dormant';
}
```

### Lazy Loading and Eager Loading Strategies

Guidelines for relation loading:

- **Listing endpoints**: Use `.select()` to pick only needed columns; never load relations
- **Detail endpoints**: Use conditional `leftJoinAndSelect()` based on query params (e.g., `?includeRoles=true`)
- **Batch loading**: Use `IN (:...ids)` queries to avoid N+1 problems
- **Cursor-based pagination**: Use `user.id > :cursor` with `ORDER BY user.id ASC` and `take(limit + 1)` for efficient paging

```typescript
// Selective loading based on caller needs
async getUserById(id: string, options: { includeRoles?: boolean } = {}) {
  const relations: string[] = [];
  if (options.includeRoles) relations.push('userRoles', 'userRoles.role');
  return this.userRepository.findOne({ where: { id, active: true }, relations });
}
```

### Caching Strategies

Layer caching on top of optimized queries:

- **Individual entity cache**: `user:{id}` with 5-minute TTL
- **List cache**: `user-list:{serialized-params}` with shorter TTL (2.5 minutes)
- **Cache invalidation**: On update, delete the individual key and all list keys
- **Cache warm-up**: Batch-load frequently accessed entities into cache on startup or schedule

```typescript
@Injectable()
export class CachedUserService {
  private readonly CACHE_TTL = 5 * 60 * 1000;

  constructor(
    @Inject(CACHE_MANAGER) private cacheManager: Cache,
    private readonly userService: PerformanceOptimizedUserService,
  ) {}
}
```

### Query Optimization Patterns

Techniques for high-performance queries:

- **Single-query counts**: Use `CASE WHEN ... THEN 1 END` inside `COUNT()` to get multiple counts in one query
- **Batch status updates**: Use `UPDATE ... SET status = CASE WHEN ... END WHERE active = true` for bulk recalculations
- **Aggregation by role**: Join through role tables and `GROUP BY` for per-role statistics
- **Full-text search**: Use `MATCH ... AGAINST` (MySQL) or `tsvector` (Postgres) with a LIKE fallback

```typescript
// Single query for multiple counts
const result = await dataSource.createQueryBuilder()
  .select([
    'COUNT(*) as total',
    'COUNT(CASE WHEN is_verified = 1 THEN 1 END) as verified',
    'COUNT(CASE WHEN activity_status = "active" THEN 1 END) as active',
  ])
  .from(UserEntity, 'user')
  .where('active = 1')
  .getRawOne();
```

This guide covers advanced entity patterns, complex relationships, performance optimization techniques, and best practices for building enterprise-level applications with the Rockets SDK. For complete file templates, use the rockets-crud-generator skill.
