# CRUD PATTERNS GUIDE

> **For AI Tools**: This guide contains CRUD implementation patterns for Rockets SDK. Use this when building entities that need CRUD operations with the latest API patterns.

## Quick Reference

| Pattern | When to Use | Complexity | Recommended |
|---------|-------------|------------|-------------|
| [Direct CRUD](#direct-crud-pattern) | Standard CRUD, fixed DTOs, explicit control | Low | **RECOMMENDED** |
| [Custom Controllers](#custom-controllers) | Special business logic, non-standard operations | Medium | *As needed* |

---

## Prerequisite: Initialize CrudModule in the root AppModule

Before using any CRUD decorators or calling `CrudModule.forFeature(...)` in feature modules, you must initialize the CRUD infrastructure once at the application root with `CrudModule.forRoot({})`.

```typescript
// app.module.ts
import { CrudModule } from '@concepta/nestjs-crud';

@Module({
  imports: [
    CrudModule.forRoot({}),
    // ...other modules
  ],
})
export class AppModule {}
```

If you skip this, NestJS will fail to resolve `CRUD_MODULE_SETTINGS_TOKEN` and show an error mentioning `Symbol(__CRUD_MODULE_RAW_OPTIONS_TOKEN__)` in the `CrudModule` context.

> **Note**: If your project uses `RocketsAuthModule.forRootAsync()` (the starter template does), it may already register `CrudModule` internally. Add `CrudModule.forRoot({})` explicitly when adding your first custom feature module to be safe -- duplicate registration is harmless.

## Pattern Decision Tree

```
Need CRUD operations for your entity?
├── Yes → **RECOMMENDED: Use Direct CRUD Pattern**
│   ├── Explicit control over all endpoints
│   ├── Clear business logic placement
│   ├── Easy debugging and maintenance
│   ├── Access control integration
│   └── Full error handling
└── Special requirements → Custom Controllers

Use Direct CRUD for all standard entity operations.
```

---

## Direct CRUD Pattern (RECOMMENDED)

### When to Use:
- All new CRUD implementations
- Standard entity operations (Create, Read, Update, Delete)
- Fixed DTOs and adapters
- Explicit control over endpoints
- Access control integration
- Business validation requirements

### Architecture Overview:

```
Controller → CRUD Service → Model Service → Adapter → Database
     ↑            ↑              ↑           ↑
Access Control | Business Logic | Validation | TypeORM
```

### Complete Implementation:

The Direct CRUD pattern produces these files for each entity:

1. **Controller** (`*.crud.controller.ts`) -- decorators + delegation
2. **CRUD Service** (`*.crud.service.ts`) -- error-wrapping layer
3. **Model Service** (`*-model.service.ts`) -- business logic + validation
4. **TypeORM Adapter** (`*-typeorm-crud.adapter.ts`) -- DB access

> Generated by rockets-crud-generator skill. See `skills/rockets-crud-generator/SKILL.md`.

---

## Key Patterns Explained

### 1. Layered Architecture

```typescript
// Clear separation of concerns
Controller  → API endpoints + access control
CRUD Service → CRUD operations + error handling
Model Service → Business logic + validation
Adapter → Database operations
```

### 2. Error Handling Pattern

```typescript
// Consistent error handling across all operations
try {
  return await super.createOne(req, dto, options);
} catch (error) {
  if (error instanceof ArtistException) {
    throw error; // Re-throw business exceptions
  }
  throw new ArtistException('Failed to create artist', { originalError: error });
}
```

### 3. Business Validation

```typescript
// Business rules in model service
async create(data: ArtistCreatableInterface): Promise<ArtistEntityInterface> {
  const isUnique = await this.isNameUnique(data.name);
  if (!isUnique) {
    throw new ArtistNameAlreadyExistsException();
  }
  const artistData = { ...data, status: data.status || ArtistStatus.ACTIVE };
  return super.create(artistData);
}
```

### 4. Access Control Integration

```typescript
// Every endpoint has access control
@CrudReadMany()
@AccessControlReadMany(ArtistResource.Many)
async getMany(@CrudRequest() crudRequest: CrudRequestInterface<ArtistEntityInterface>) {
  return this.artistCrudService.getMany(crudRequest);
}
```

### 5. Constants Usage

```typescript
import { ArtistResource } from './artist.constants';

@AccessControlReadMany(ArtistResource.Many)

// Constants file structure
export const ArtistResource = {
  One: 'artist-one',
  Many: 'artist-many',
} as const;
```

---

## Custom Controllers (When Needed)

### When to Use Custom Controllers:
- Special business operations not covered by CRUD
- Complex data transformations
- Multi-entity operations
- File uploads or downloads
- Reporting endpoints

### Custom logic (non-CRUD)

Any logic that is **not** standard CRUD (custom services, aggregation, cross-entity use) must **not** inject repositories in application services. It must use the **model service** of each entity it needs. Modules with custom logic or cross-module dependencies should expose a **model service** for their entity so that other modules and custom logic can depend on it. Repositories belong only in adapters and model services. See [SDK_SERVICES_GUIDE.md](./SDK_SERVICES_GUIDE.md) and the **rockets-custom-code** skill for the full rule and examples.

### Example: Custom Business Endpoint

```typescript
@Controller('artists')
@ApiTags('artists-custom')
export class ArtistCustomController {
  constructor(private artistModelService: ArtistModelService) {}

  @Get('active')
  async getActiveArtists(): Promise<ArtistDto[]> {
    return (await this.artistModelService.getActiveArtists())
      .map(artist => new ArtistDto(artist));
  }

  @Post(':id/deactivate')
  async deactivateArtist(@Param('id') id: string): Promise<ArtistDto> {
    return new ArtistDto(await this.artistModelService.deactivateArtist(id));
  }
}
```

---

## CRUD vs Custom Decision Matrix

| Operation | Use CRUD | Use Custom |
|-----------|----------|------------|
| Get all entities | `getMany()` | |
| Get entity by ID | `getOne()` | |
| Create entity | `createOne()` | |
| Update entity | `updateOne()` | |
| Delete entity | `deleteOne()` | |
| Bulk create | `createMany()` | |
| Search/filter | Query params | Complex searches |
| Get active only | | Custom endpoint |
| Bulk operations | | Custom endpoint |
| File uploads | | Custom endpoint |
| Reports/analytics | | Custom endpoint |
| Multi-entity ops | | Custom endpoint |

---

## Best Practices

### 1. Always Use Direct CRUD for Standard Operations
```typescript
// Good - Standard CRUD
@CrudController({ path: 'artists' })
export class ArtistCrudController implements CrudControllerInterface {}

// Avoid - Custom implementation of standard CRUD
@Controller('artists')
export class ArtistController {
  @Get() getAllArtists() {} // Don't reinvent CRUD
}
```

### 2. Put Business Logic in Model Service
```typescript
// Good - Business logic in model service
async create(data: ArtistCreatableInterface) {
  const isUnique = await this.isNameUnique(data.name);
  if (!isUnique) throw new ArtistNameAlreadyExistsException();
  return super.create(data);
}
```

### 3. Handle Errors Consistently
```typescript
try {
  return await super.createOne(req, dto, options);
} catch (error) {
  if (error instanceof ArtistException) throw error;
  throw new ArtistException('Failed to create artist', { originalError: error });
}
```

### 4. Use Constants for Resources
```typescript
// Good
import { ArtistResource } from './artist.constants';
@AccessControlReadMany(ArtistResource.Many)

// Avoid - Hard-coded strings
@AccessControlReadMany('artist-many')
```

### 5. Keep Adapters Simple
```typescript
export class ArtistTypeOrmCrudAdapter extends TypeOrmCrudAdapter<ArtistEntity> {
  constructor(@InjectRepository(ArtistEntity) repo: Repository<ArtistEntity>) {
    super(repo);
  }
}
```

---

## Integration with Module System

### Module Configuration:

> Generated by rockets-crud-generator skill. See `skills/rockets-crud-generator/SKILL.md`.

The module must include:
- `TypeOrmModule.forFeature([Entity])` and `TypeOrmExtModule.forFeature({ [ENTITY_KEY]: { entity: Entity } })`
- All controllers registered
- All providers: adapter, model service, CRUD service, access query service
- Exports: model service and adapter (for cross-module use)

---

## Performance Tips

### 1. Use Eager Loading for Relationships
```typescript
@ManyToOne(() => GenreEntity, { eager: true })
genre: GenreEntity;
```

### 2. Implement Proper Indexing
```typescript
@Index(['name'])
@Column({ unique: true })
name: string;
```

### 3. Use Query Optimization
```typescript
// In model service - Use QueryBuilder for complex queries
async findActiveWithAlbums(): Promise<ArtistEntityInterface[]> {
  return this.repo.createQueryBuilder('artist')
    .leftJoinAndSelect('artist.albums', 'album')
    .where('artist.status = :status', { status: ArtistStatus.ACTIVE })
    .orderBy('artist.name', 'ASC')
    .getMany();
}
```

---

## Success Metrics

**Your CRUD implementation is optimized when:**
- All standard operations use Direct CRUD pattern
- Business logic is centralized in model service
- Error handling is consistent across all operations
- Access control is properly implemented
- Custom endpoints only for non-standard operations
- Adapters are simple and focused
- Constants are used for all resource definitions

---

## CRUD Relations Patterns

CRUD Relations enable you to automatically fetch related data when querying your main entity. Instead of making separate requests for each relation, you get nested JSON responses with all related data included.

### What CRUD Relations Solve

**Without Relations** (N+1 Problem):
```typescript
const pet = await fetch('/pets/123');
const vaccinations = await fetch('/pets/123/vaccinations');
const appointments = await fetch('/pets/123/appointments');
```

**With Relations** (Single Request):
```typescript
const petWithRelations = await fetch('/pets/123');
// Returns: { id, name, vaccinations: [...], appointments: [...] }
```

### Relations Quick Reference

| Pattern | When to Use | Complexity | Registry Required |
|---------|-------------|------------|-------------------|
| [ConfigurableCrudBuilder](#configurablecrudbuilder-relations-pattern) | Complex admin interfaces, custom service logic | High | Manual |
| [Direct @CrudController](#direct-crudcontroller-relations-pattern) | Simple entity relations, straightforward operations | Low | Automatic |

### Adapter-Agnostic Relations

CRUD Relations work with **any data source**, not just databases. TypeORM decorators (`@OneToMany`, `@ManyToOne`, etc.) are **only needed for TypeORM database mapping**. The CRUD Relations system uses the **service adapters** to fetch related data, regardless of the underlying data source (JSON files, Supabase, Firebase, etc.).

### How to Set Up CRUD Relations

#### Step 1: Configure Relations on the Controller

**Option A: Directly on @CrudController**
```typescript
@CrudController({ path: 'pets' })
@CrudRelations<PetEntity, [PetVaccinationEntity]>({
  rootKey: 'id',
  relations: [{
    join: 'LEFT',
    cardinality: 'many',
    service: PetVaccinationCrudService,
    property: 'vaccinations',
    primaryKey: 'id',
    foreignKey: 'petId',
  }],
})
export class PetCrudController { }
```

**Option B: On extraDecorators with ConfigurableCrudBuilder**
```typescript
const builder = new ConfigurableCrudBuilder({
  controller: {
    path: 'admin/pets',
    extraDecorators: [
      CrudRelations<PetEntity, [PetVaccinationEntity]>({
        rootKey: 'id',
        relations: [{ /* same config as above */ }],
      }),
    ],
  },
});
```

#### Step 2: Register Services in Providers

All relation services must be available through dependency injection:

```typescript
providers: [
  PetCrudService,
  PetVaccinationCrudService,     // Relation service (required)
  PetAppointmentCrudService,     // Relation service (required)
]
```

#### Step 3: Configure Relation Registry (Always Required)

```typescript
{
  provide: 'PET_RELATION_REGISTRY',
  inject: [PetVaccinationCrudService, PetAppointmentCrudService],
  useFactory: (vaccinationSvc, appointmentSvc) => {
    const registry = new CrudRelationRegistry<
      PetEntityInterface,
      [PetVaccinationEntity, PetAppointmentEntity]
    >();
    registry.register(vaccinationSvc);
    registry.register(appointmentSvc);
    return registry;
  },
}
```

Then inject the registry into the CRUD service constructor:
```typescript
constructor(
  @Inject(PetTypeOrmCrudAdapter)
  protected readonly crudAdapter: PetTypeOrmCrudAdapter,
  @Inject('PET_RELATION_REGISTRY')
  protected readonly relationRegistry: CrudRelationRegistry,
) {
  super(crudAdapter, relationRegistry);
}
```

### Relationship Configuration Reference

| Field | Description | Example Values |
|-------|-------------|----------------|
| `join` | SQL JOIN type | `'LEFT'`, `'INNER'` |
| `cardinality` | Relationship type | `'one'` (single object), `'many'` (array) |
| `service` | CRUD service class | `PetVaccinationCrudService` |
| `property` | JSON property name | `'vaccinations'`, `'medicalRecord'` |
| `primaryKey` | Main entity key | `'id'` |
| `foreignKey` | Related entity key | `'petId'`, `'userId'` |

### Key Benefits

- **Performance**: Fetch all related data in optimized queries
- **Simplicity**: Declarative configuration, no manual query building
- **Type Safety**: Full TypeScript support with proper typing
- **Consistency**: Relations work the same across different CRUD services
- **Flexibility**: Services can use different adapters (database, files, APIs)

---

## Pattern Selection Guide

| Requirement | ConfigurableCrudBuilder | Direct @CrudController |
|-------------|-------------------------|------------------------|
| **Complexity** | High (admin interfaces) | Low (standard operations) |
| **Business Logic** | Complex validation, transformation | Simple CRUD with relations |
| **Configuration** | Dynamic, flexible | Fixed, declarative |
| **Registry Setup** | Manual (full control) | Automatic (convention) |
| **Learning Curve** | Steep | Gentle |
| **Use Cases** | Admin panels, complex workflows | User-facing APIs, simple relations |

**Quick Decision:**
- **ConfigurableCrudBuilder**: Complex business logic, dynamic configuration, fine-grained control
- **Direct @CrudController**: Standard CRUD operations with relations (recommended for most cases)

---

## ConfigurableCrudBuilder Relations Pattern

### Key Features:
1. **Advanced Configuration**: Uses `ConfigurableCrudBuilder` for complex setup
2. **Custom Business Logic**: Extended service class with validation and custom methods
3. **Manual Registry**: Explicit registration of relation services in `CrudRelationRegistry`
4. **Dynamic Module**: Flexible module configuration with injectable tokens
5. **Full Control**: Complete control over each CRUD operation and relation handling

> Full implementation template generated by rockets-crud-generator skill. See `skills/rockets-crud-generator/SKILL.md`.

---

## Direct @CrudController Relations Pattern

### When to Use:
- Simple entity relations (pet with vaccinations and appointments)
- Straightforward CRUD operations with automatic relation loading
- Minimal configuration required
- Standard access control patterns
- Quick development without complex business logic

### Key Features:
1. **Simple Configuration**: Direct use of `@CrudController` and `@CrudRelations` decorators
2. **Multiple Relations**: Easy to define multiple related entities
3. **Automatic Registry**: No manual `CrudRelationRegistry` registration needed
4. **Access Control Integration**: Works seamlessly with access control guards and ownership filtering
5. **Standard CRUD Service**: Uses standard CRUD service without complex customization

> Full implementation template generated by rockets-crud-generator skill. See `skills/rockets-crud-generator/SKILL.md`.

### Module Registration Requirements:

The module must register all relation entities in `TypeOrmModule.forFeature(...)` and provide all relation CRUD services. In the Direct Pattern, the `@CrudRelations` decorator handles the registry automatically, but the services must still be available through dependency injection.

---

## Common CRUD Relations Mistakes

### Mistake 1: Missing @Type() Decorator

```typescript
// WRONG: No @Type decorator
@Expose()
vaccinations?: PetVaccinationDto[];

// CORRECT: With @Type decorator
@Expose()
@Type(() => PetVaccinationDto)  // CRITICAL for serialization
@ValidateNested({ each: true })
vaccinations?: PetVaccinationDto[];
```

### Mistake 2: Not Registering Related Service

```typescript
// WRONG: Service not registered in registry
useFactory: () => new CrudRelationRegistry()
// Missing: registry.register(vaccinationService)

// CORRECT: Service properly registered
useFactory: (vaccinationService) => {
  const registry = new CrudRelationRegistry();
  registry.register(vaccinationService);  // REQUIRED
  return registry;
}
```

### Mistake 3: Swapped Primary/Foreign Keys

```typescript
// WRONG
primaryKey: 'petId',    // This is on related entity!
foreignKey: 'id',       // This is on root entity!

// CORRECT
primaryKey: 'id',       // Pet.id (root entity)
foreignKey: 'petId',    // PetVaccination.petId (related entity)
```

### Mistake 4: Wrong Cardinality

```typescript
// WRONG: Cardinality doesn't match TypeORM relationship
// @OneToMany on entity but cardinality: 'one' in config

// CORRECT: Matching cardinality
// @OneToMany → cardinality: 'many'
// @OneToOne  → cardinality: 'one'
```

### Mistake 5: Missing Entity Registration

```typescript
// WRONG: Only root entity registered
TypeOrmModule.forFeature([PetEntity])  // Missing related entities!

// CORRECT: All entities registered
TypeOrmModule.forFeature([
  PetEntity,
  PetVaccinationEntity,      // Required for relations
  PetAppointmentEntity,      // Required for relations
])
```

### Mistake 6: Not Re-fetching After Update

```typescript
// WRONG: Returns stale data
async updateOne(req, dto) {
  const pet = await super.updateOne(req, petData);
  await this.vaccinationService.updateMany(vaccinations);
  return pet;  // Vaccinations are not updated in response!
}

// CORRECT: Re-fetch to get fresh relations
async updateOne(req, dto) {
  await super.updateOne(req, petData);
  await this.vaccinationService.updateMany(vaccinations);
  return super.getOne(req);  // Fresh data with updated relations
}
```

### Mistake 7: Circular Dependency

```typescript
// WRONG: Direct circular dependency between services

// CORRECT: Use forwardRef
inject: [forwardRef(() => PetVaccinationCrudService)],
```

---

## CRUD Relations Troubleshooting Checklist

When relations don't work, check these items:

### Setup Checklist

- [ ] All entities registered in `TypeOrmModule.forFeature([...])`?
- [ ] Related service registered in registry?
- [ ] Registry injected into main service?
- [ ] `@CrudRelations` decorator on controller?
- [ ] Correct `primaryKey`/`foreignKey` mapping?
- [ ] `@Type(() => RelatedDto)` on DTO properties?

### Common Error Messages

| Error | Likely Cause | Solution |
|-------|--------------|----------|
| "Cannot resolve dependency" | Service not in registry | Add service to registry factory |
| "Relations not appearing" | Missing @Type() decorator | Add @Type(() => RelatedDto) |
| "Circular dependency" | Module dependency loop | Use forwardRef() |
| "Entity not found" | Missing TypeORM registration* | Add to TypeOrmModule.forFeature() |
| "primaryKey/foreignKey" | Swapped key configuration | Check key mapping direction |

*Only applies when using TypeORM adapter. Other adapters have different registration patterns.*

### Debug Steps

1. **Check Network Tab**: Are related entities being fetched?
2. **Check Logs**: Any errors during service resolution?
3. **Check Registry**: Is the related service actually registered?
4. **Check DTOs**: Do they have proper decorators?
5. **Check Module**: Are all entities and services provided?

---

## Relations Best Practices

### 1. Service Registration

**ConfigurableCrudBuilder Pattern** (Manual Registration Required):
```typescript
{
  provide: PET_RELATION_REGISTRY_TOKEN,
  inject: [PetVaccinationCrudService, PetAppointmentCrudService],
  useFactory: (vaccinationSvc, appointmentSvc) => {
    const registry = new CrudRelationRegistry();
    registry.register(vaccinationSvc);
    registry.register(appointmentSvc);
    return registry;
  },
}
```

**Direct @CrudController Pattern** (Automatic Registration):
```typescript
// Just provide the services in the module
providers: [
  PetCrudService,
  PetVaccinationCrudService, // Must be provided for relations
  PetAppointmentCrudService, // Must be provided for relations
]
```

### 2. Pattern Selection

- **ConfigurableCrudBuilder**: Complex business logic, custom service methods, admin interfaces
- **Direct @CrudController**: Simple CRUD operations, straightforward relations, quick development

### 3. Performance Considerations

- **Avoid deep nesting** of relations (max 2-3 levels)
- **Use LEFT JOIN** to include records even when related data doesn't exist
- **Consider pagination** for endpoints that return many related records
- **Monitor query performance** and optimize as needed

### 4. Error Handling

```typescript
// ConfigurableCrudBuilder: Custom error handling in service
async updateOne(req, dto) {
  try {
    const result = await super.updateOne(req, userDto);
    if (metadata) {
      await this.metadataService.createOrUpdate(result.id, metadata);
    }
    return await super.getOne(req);
  } catch (error) {
    this.logger.error('Update with relations failed', { error: error.message });
    throw new BadRequestException('Update failed');
  }
}
```

---

## CRUD Relations Success Criteria

### Implementation Checklist

**Your CRUD relations implementation is correct when:**

#### Setup Requirements:
- All entities registered in `TypeOrmModule.forFeature([...])`
- All relation services registered in `CrudRelationRegistry`
- Registry injected into main CRUD service constructor
- `@CrudRelations` decorator properly configured on controller
- Correct `primaryKey`/`foreignKey` mapping (not swapped)
- Cardinality matches TypeORM relationships ('one' vs 'many')

#### DTO Requirements:
- `@Type(() => RelatedDto)` decorator on nested properties
- `@ValidateNested()` decorator for validation
- `@IsArray()` and `{ each: true }` for array relationships
- Proper Swagger documentation with nested types

#### Functional Requirements:
- **GET requests** return entities with nested relations
- **POST requests** create entities with nested data successfully
- **PATCH requests** update entities and relations correctly
- **DELETE requests** handle related data appropriately
- No TypeScript compilation errors
- All tests pass

#### Runtime Verification:
- Relations appear in API responses
- Create operations with nested data work
- Update operations refresh relation data
- Error handling works gracefully for relation failures
- Performance is acceptable (no N+1 query problems)

### API Testing Checklist

Test these scenarios to verify your implementation:

```bash
# 1. Create with relations
POST /pets
{ "name": "Buddy", "vaccinations": [{ "vaccineName": "Rabies" }] }

# 2. Read with relations
GET /pets/123
# Should return: { id, name, vaccinations: [...] }

# 3. Update with relations
PATCH /pets/123
{ "name": "Buddy Updated" }

# 4. List with relations
GET /pets
# Should return array with nested relations
```

### Common Issues and Quick Fixes

| Issue | Quick Fix |
|-------|-----------|
| Relations not appearing | Check `@Type(() => RelatedDto)` on DTO |
| "Cannot resolve dependency" | Add service to registry factory |
| TypeScript errors | Verify generic types match entities |
| Stale data after update | Use `return super.getOne(req)` |
| Circular dependency | Use `forwardRef()` in registry |

---

## Quality Checklist (Post-Generation)

Use this checklist after running `rockets-crud-generator` to verify the output.

### Generated Code Must Have:

**File Structure:**
- [ ] All 12 files created in correct order (including constants, index)
- [ ] Consistent naming conventions throughout
- [ ] Proper imports and dependencies

**Entity & Database:**
- [ ] TypeORM entity extends CommonPostgresEntity
- [ ] Primary key, timestamps, status enum
- [ ] Relationships properly defined
- [ ] Entity implements EntityInterface

**DTOs & Validation:**
- [ ] All DTOs have `@Exclude()` at class level (expose only what is needed via `@Expose()`)
- [ ] Base DTO extends CommonEntityDto
- [ ] Create/Update DTOs use PickType and IntersectionType patterns
- [ ] All fields have validation decorators
- [ ] Nested objects/arrays use `@ValidateNested()` (and `@ValidateNested({ each: true })` for arrays) and `@Type(() => ChildDto)`
- [ ] ApiProperty documentation complete
- [ ] Pagination DTO extends CrudResponsePaginatedDto

**Constants & Resources:**
- [ ] Constants file with module entity key
- [ ] Resource definitions for access control
- [ ] Proper imports from constants file

**Error Handling:**
- [ ] Base exception extends RuntimeException
- [ ] Specific exceptions for business rules
- [ ] HTTP status codes set correctly
- [ ] Error codes follow naming convention

**Business Logic:**
- [ ] Model service extends ModelService base class
- [ ] Model service implements ModelServiceInterface
- [ ] Protected createDto and updateDto properties defined
- [ ] Business validation in create/update methods
- [ ] Custom business methods (findByName, isNameUnique, etc.)
- [ ] Unit test file `{entity}-model.service.spec.ts` added when adding a ModelService

**CRUD Adapter:**
- [ ] Adapter extends TypeOrmCrudAdapter base class
- [ ] Simple constructor with repository injection
- [ ] Clean, minimal implementation

**CRUD Service:**
- [ ] Service extends CrudService base class
- [ ] Proper error handling with EntityException pattern
- [ ] Try-catch blocks for create/update/delete operations

**Access Control:**
- [ ] Access service implements CanAccess interface
- [ ] Basic canAccess method (customize as needed)
- [ ] Controller decorators applied correctly

**Controller:**
- [ ] Uses @CrudController decorator with proper configuration
- [ ] All CRUD endpoints implemented
- [ ] Access control decorators on all endpoints
- [ ] Proper JSDoc documentation with business rules
- [ ] @AuthPublic() decorator if authentication is optional

**Module Configuration:**
- [ ] Both TypeORM imports (standard + extended)
- [ ] All services registered in providers
- [ ] Proper exports for reusability
- [ ] Controller registered
- [ ] Constants imported and used correctly

**App-Level Integration:**
- [ ] `AccessControlModule.forRoot({ rules: acRules })` imported in `AppModule`
- [ ] Entity registered in `ormconfig.ts`
- [ ] Resource added to `AppResource` enum (or equivalent) in `app.acl.ts`
- [ ] `acRules` cover all role x resource combinations
- [ ] Module imported in `app.module.ts`

**Security (Ownership Entities):**
- [ ] Ownership fields (e.g. `userId`) NOT in create DTO -- injected from `@AuthUser()` in controller
- [ ] `getMany` filters results by `userId` for `readOwn` users
- [ ] Access query service checks `context.getRequest()?.params?.id` for entity ownership
- [ ] FK columns (`userId`, `categoryId`) have `@Index()` decorators for query performance

### Compilation-Breaking Patterns (MUST avoid):

- **PaginatedDto `data` field**: ALWAYS use `declare data: EntityDto[]` (NOT `data!: EntityDto[]`). The base class `CrudResponsePaginatedDto` already defines `data`; redeclaring with `!` causes TS2612.
- **ModelUpdatableInterface `id` field**: MUST be `id: string` (required), NOT `id?: string` (optional). `UpdateOneInterface<T>` constrains T to `ReferenceIdInterface<string>`.
- **ModelUpdateDto `id` field**: MUST be `id!: string` (required with definite assignment), matching the interface.
- **Entity interface must include relation fields**: If your entity has `@ManyToOne`/`@OneToMany`, add those fields to the EntityInterface (e.g. `category?: unknown`).
- **EventModule is required**: `EventModule.forRoot({})` from `@concepta/nestjs-event` MUST be imported in AppModule before RocketsAuthModule.
- **TypeOrmExtModule.forFeature MUST include ALL entity keys**: All 7 keys: `user`, `role`, `userRole`, `userOtp`, `federated`, `invitation`, `userMetadata`.
- **Package names**: `@bitwild/rockets` and `@bitwild/rockets-auth` (NOT `rockets-server` / `rockets-server-auth`).
- **TypeORM version pinning**: Pin `typeorm` to exact `0.3.20` (no caret).
- **TypeOrmExtDataSourceOptions not exported**: Use implicit return type for `ormSettingsFactory()`.
- **@AuthPublic() + @AccessControlQuery incompatibility**: Controllers with `@AuthPublic()` MUST NOT use `@AccessControlQuery` or `@AccessControl*` decorators. Use only `@Crud*` decorators for public endpoints.

### Common AI Generation Issues:

- Missing `@Exclude()` on ALL DTO classes (not just the base DTO)
- Missing `@ValidateNested` + `@IsArray` + `@Type` on bulk arrays
- Ownership fields (`userId`) in create DTOs -- inject from `@AuthUser()` instead
- Missing `AccessControlModule.forRoot({ rules: acRules })` in AppModule
- Non-CRUD controllers missing `@AccessControlQuery` at class level
- Own-scope list filtering: `getMany` must filter by `userId` for `readOwn` users
- Dual resource definitions: use one source of truth (`AppResource` enum)

---

## Related Guides

- [TESTING_GUIDE.md](./TESTING_GUIDE.md) - Test CRUD operations
- [ACCESS_CONTROL_GUIDE.md](./ACCESS_CONTROL_GUIDE.md) - Secure CRUD endpoints
- [ROCKETS_AI_INDEX.md](./ROCKETS_AI_INDEX.md) - Navigation hub
